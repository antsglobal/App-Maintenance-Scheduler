{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, NgModule, EventEmitter, Injectable, Inject } from '@angular/core';\nimport { connect, MqttClient } from 'mqtt-browser';\nimport * as extend from 'xtend';\nimport { BehaviorSubject, Subject, using, Subscription, merge, Observable } from 'rxjs';\nimport { publishReplay, publish, filter, refCount } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'mqtt-browser';\nvar MqttConnectionState = /*#__PURE__*/(() => {\n  (function (MqttConnectionState) {\n    MqttConnectionState[MqttConnectionState[\"CLOSED\"] = 0] = \"CLOSED\";\n    MqttConnectionState[MqttConnectionState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    MqttConnectionState[MqttConnectionState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n  })(MqttConnectionState || (MqttConnectionState = {}));\n\n  return MqttConnectionState;\n})();\nconst MQTT_SERVICE_OPTIONS = {\n  connectOnCreate: true,\n  hostname: 'localhost',\n  port: 1884,\n  path: ''\n};\nconst MqttServiceConfig = new InjectionToken('NgxMqttServiceConfig');\nconst MqttClientService = new InjectionToken('NgxMqttClientService');\nlet MqttModule = /*#__PURE__*/(() => {\n  class MqttModule {\n    static forRoot(config, client) {\n      return {\n        ngModule: MqttModule,\n        providers: [{\n          provide: MqttServiceConfig,\n          useValue: config\n        }, {\n          provide: MqttClientService,\n          useValue: client\n        }]\n      };\n    }\n\n  }\n\n  MqttModule.ɵfac = function MqttModule_Factory(t) {\n    return new (t || MqttModule)();\n  };\n\n  MqttModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MqttModule\n  });\n  MqttModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return MqttModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * With an instance of MqttService, you can observe and subscribe to MQTT in multiple places, e.g. in different components,\n * to only subscribe to the broker once per MQTT filter.\n * It also handles proper unsubscription from the broker, if the last observable with a filter is closed.\n */\n\n\nlet MqttService = /*#__PURE__*/(() => {\n  class MqttService {\n    /**\n     * The constructor needs [connection options]{@link IMqttServiceOptions} regarding the broker and some\n     * options to configure behavior of this service, like if the connection to the broker\n     * should be established on creation of this service or not.\n     */\n    constructor(options, client) {\n      this.options = options;\n      this.client = client;\n      /** a map of all mqtt observables by filter */\n\n      this.observables = {};\n      /** the connection state */\n\n      this.state = new BehaviorSubject(MqttConnectionState.CLOSED);\n      /** an observable of the last mqtt message */\n\n      this.messages = new Subject();\n      this._clientId = this._generateClientId();\n      this._connectTimeout = 10000;\n      this._reconnectPeriod = 10000;\n      this._url = undefined;\n      this._onConnect = new EventEmitter();\n      this._onReconnect = new EventEmitter();\n      this._onClose = new EventEmitter();\n      this._onOffline = new EventEmitter();\n      this._onError = new EventEmitter();\n      this._onEnd = new EventEmitter();\n      this._onMessage = new EventEmitter();\n      this._onSuback = new EventEmitter();\n      this._onPacketsend = new EventEmitter();\n      this._onPacketreceive = new EventEmitter();\n\n      this._handleOnConnect = e => {\n        if (this.options.connectOnCreate === true) {\n          Object.keys(this.observables).forEach(filterString => {\n            this.client.subscribe(filterString);\n          });\n        }\n\n        this.state.next(MqttConnectionState.CONNECTED);\n\n        this._onConnect.emit(e);\n      };\n\n      this._handleOnReconnect = () => {\n        if (this.options.connectOnCreate === true) {\n          Object.keys(this.observables).forEach(filterString => {\n            this.client.subscribe(filterString);\n          });\n        }\n\n        this.state.next(MqttConnectionState.CONNECTING);\n\n        this._onReconnect.emit();\n      };\n\n      this._handleOnClose = () => {\n        this.state.next(MqttConnectionState.CLOSED);\n\n        this._onClose.emit();\n      };\n\n      this._handleOnOffline = () => {\n        this._onOffline.emit();\n      };\n\n      this._handleOnError = e => {\n        this._onError.emit(e);\n\n        console.error(e);\n      };\n\n      this._handleOnEnd = () => {\n        this._onEnd.emit();\n      };\n\n      this._handleOnMessage = (topic, payload, packet) => {\n        this._onMessage.emit(packet);\n\n        if (packet.cmd === 'publish') {\n          this.messages.next(packet);\n        }\n      };\n\n      this._handleOnPacketsend = e => {\n        this._onPacketsend.emit();\n      };\n\n      this._handleOnPacketreceive = e => {\n        this._onPacketreceive.emit();\n      };\n\n      if (options.connectOnCreate !== false) {\n        this.connect({}, client);\n      }\n\n      this.state.subscribe();\n    }\n    /**\n     * gets the _clientId\n     */\n\n\n    get clientId() {\n      return this._clientId;\n    }\n    /** An EventEmitter to listen to connect messages */\n\n\n    get onConnect() {\n      return this._onConnect;\n    }\n    /** An EventEmitter to listen to reconnect messages */\n\n\n    get onReconnect() {\n      return this._onReconnect;\n    }\n    /** An EventEmitter to listen to close messages */\n\n\n    get onClose() {\n      return this._onClose;\n    }\n    /** An EventEmitter to listen to offline events */\n\n\n    get onOffline() {\n      return this._onOffline;\n    }\n    /** An EventEmitter to listen to error events */\n\n\n    get onError() {\n      return this._onError;\n    }\n    /** An EventEmitter to listen to close messages */\n\n\n    get onEnd() {\n      return this._onEnd;\n    }\n    /** An EventEmitter to listen to message events */\n\n\n    get onMessage() {\n      return this._onMessage;\n    }\n    /** An EventEmitter to listen to packetsend messages */\n\n\n    get onPacketsend() {\n      return this._onPacketsend;\n    }\n    /** An EventEmitter to listen to packetreceive messages */\n\n\n    get onPacketreceive() {\n      return this._onPacketreceive;\n    }\n    /** An EventEmitter to listen to suback events */\n\n\n    get onSuback() {\n      return this._onSuback;\n    }\n    /**\n     * This static method shall be used to determine whether a MQTT\n     * topic matches a given filter. The matching rules are specified in the MQTT\n     * standard documentation and in the library test suite.\n     *\n     * @param  {string}  filter A filter may contain wildcards like '#' and '+'.\n     * @param  {string}  topic  A topic may not contain wildcards.\n     * @return {boolean}        true on match and false otherwise.\n     */\n\n\n    static filterMatchesTopic(filterString, topic) {\n      if (filterString[0] === '#' && topic[0] === '$') {\n        return false;\n      } // Preparation: split and reverse on '/'. The JavaScript split function is sane.\n\n\n      const fs = (filterString || '').split('/').reverse();\n      const ts = (topic || '').split('/').reverse(); // This function is tail recursive and compares both arrays one element at a time.\n\n      const match = () => {\n        // Cutting of the last element of both the filter and the topic using pop().\n        const f = fs.pop();\n        const t = ts.pop();\n\n        switch (f) {\n          // In case the filter level is '#', this is a match no matter whether\n          // the topic is undefined on this level or not ('#' matches parent element as well!).\n          case '#':\n            return true;\n          // In case the filter level is '+', we shall dive into the recursion only if t is not undefined.\n\n          case '+':\n            return t ? match() : false;\n          // In all other cases the filter level must match the topic level,\n          // both must be defined and the filter tail must match the topic\n          // tail (which is determined by the recursive call of match()).\n\n          default:\n            return f === t && (f === undefined ? true : match());\n        }\n      };\n\n      return match();\n    }\n    /**\n     * connect manually connects to the mqtt broker.\n     */\n\n\n    connect(opts, client) {\n      const options = extend(this.options || {}, opts);\n      const protocol = options.protocol || 'ws';\n      const hostname = options.hostname || 'localhost';\n\n      if (options.url) {\n        this._url = options.url;\n      } else {\n        this._url = `${protocol}://${hostname}`;\n        this._url += options.port ? `:${options.port}` : '';\n        this._url += options.path ? `${options.path}` : '';\n      }\n\n      this.state.next(MqttConnectionState.CONNECTING);\n      const mergedOptions = extend({\n        clientId: this._clientId,\n        reconnectPeriod: this._reconnectPeriod,\n        connectTimeout: this._connectTimeout\n      }, options);\n\n      if (this.client) {\n        this.client.end(true);\n      }\n\n      if (!client) {\n        this.client = connect(this._url, mergedOptions);\n      } else {\n        this.client = client;\n      }\n\n      this._clientId = mergedOptions.clientId;\n      this.client.on('connect', this._handleOnConnect);\n      this.client.on('reconnect', this._handleOnReconnect);\n      this.client.on('close', this._handleOnClose);\n      this.client.on('offline', this._handleOnOffline);\n      this.client.on('error', this._handleOnError);\n      this.client.stream.on('error', this._handleOnError);\n      this.client.on('end', this._handleOnEnd);\n      this.client.on('message', this._handleOnMessage);\n      this.client.on('packetsend', this._handleOnPacketsend);\n      this.client.on('packetreceive', this._handleOnPacketreceive);\n    }\n    /**\n     * disconnect disconnects from the mqtt client.\n     * This method `should` be executed when leaving the application.\n     */\n\n\n    disconnect(force = true) {\n      if (!this.client) {\n        throw new Error('mqtt client not connected');\n      }\n\n      this.client.end(force);\n    }\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     * Every new subscriber gets the latest message.\n     */\n\n\n    observeRetained(filterString, opts = {\n      qos: 1\n    }) {\n      return this._generalObserve(filterString, () => publishReplay(1), opts);\n    }\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     */\n\n\n    observe(filterString, opts = {\n      qos: 1\n    }) {\n      return this._generalObserve(filterString, () => publish(), opts);\n    }\n    /**\n     * With this method, you can observe messages for a mqtt topic.\n     * The observable will only emit messages matching the filter.\n     * The first one subscribing to the resulting observable executes a mqtt subscribe.\n     * The last one unsubscribing this filter executes a mqtt unsubscribe.\n     * Depending on the publish function, the messages will either be replayed after new\n     * subscribers subscribe or the messages are just passed through\n     */\n\n\n    _generalObserve(filterString, publishFn, opts) {\n      if (!this.client) {\n        throw new Error('mqtt client not connected');\n      }\n\n      if (!this.observables[filterString]) {\n        const rejected = new Subject();\n        this.observables[filterString] = using( // resourceFactory: Do the actual ref-counting MQTT subscription.\n        // refcount is decreased on unsubscribe.\n        () => {\n          const subscription = new Subscription();\n          this.client.subscribe(filterString, opts, (err, granted) => {\n            if (granted) {\n              // granted can be undefined when an error occurs when the client is disconnecting\n              granted.forEach(granted_ => {\n                if (granted_.qos === 128) {\n                  delete this.observables[granted_.topic];\n                  this.client.unsubscribe(granted_.topic);\n                  rejected.error(`subscription for '${granted_.topic}' rejected!`);\n                }\n\n                this._onSuback.emit({\n                  filter: filterString,\n                  granted: granted_.qos !== 128\n                });\n              });\n            }\n          });\n          subscription.add(() => {\n            delete this.observables[filterString];\n            this.client.unsubscribe(filterString);\n          });\n          return subscription;\n        }, // observableFactory: Create the observable that is consumed from.\n        // This part is not executed until the Observable returned by\n        // `observe` gets actually subscribed.\n        subscription => merge(rejected, this.messages)).pipe(filter(msg => MqttService.filterMatchesTopic(filterString, msg.topic)), publishFn(), refCount());\n      }\n\n      return this.observables[filterString];\n    }\n    /**\n     * This method returns an observable for a topic with optional options.\n     * After subscribing, the actual mqtt publication will be executed and\n     * the observable will emit an empty value and completes, if publishing was successful\n     * or throws an error, if the publication fails.\n     */\n\n\n    publish(topic, message, options = {}) {\n      if (!this.client) {\n        throw new Error('mqtt client not connected');\n      }\n\n      return Observable.create(obs => {\n        this.client.publish(topic, message, options, error => {\n          if (error) {\n            obs.error(error);\n          } else {\n            obs.next(null);\n            obs.complete();\n          }\n        });\n      });\n    }\n    /**\n     * This method publishes a message for a topic with optional options.\n     * If an error occurs, it will throw.\n     */\n\n\n    unsafePublish(topic, message, options = {}) {\n      if (!this.client) {\n        throw new Error('mqtt client not connected');\n      }\n\n      this.client.publish(topic, message, options, error => {\n        if (error) {\n          throw error;\n        }\n      });\n    }\n\n    _generateClientId() {\n      return 'client-' + Math.random().toString(36).substr(2, 19);\n    }\n\n  }\n\n  MqttService.ɵfac = function MqttService_Factory(t) {\n    return new (t || MqttService)(ɵngcc0.ɵɵinject(MqttServiceConfig), ɵngcc0.ɵɵinject(MqttClientService));\n  };\n\n  MqttService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function MqttService_Factory() {\n      return new MqttService(i0.ɵɵinject(MqttServiceConfig), i0.ɵɵinject(MqttClientService));\n    },\n    token: MqttService,\n    providedIn: \"root\"\n  });\n  return MqttService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ngx-mqtt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MQTT_SERVICE_OPTIONS, MqttClientService, MqttConnectionState, MqttModule, MqttService, MqttServiceConfig }; //# sourceMappingURL=ngx-mqtt.js.map","map":null,"metadata":{},"sourceType":"module"}